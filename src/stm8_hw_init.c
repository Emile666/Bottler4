/*==================================================================
  File Name    : stm8_hw_init.c
  Author       : Emile
  ------------------------------------------------------------------
  Purpose : This files initializes all the hardware peripherals 
            of the STM8S105C6T6 uC.
  ------------------------------------------------------------------
  STM8_HW_INIT is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
 
  STM8_HW_INIT is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with STM8_HW_INIT. If not, see <http://www.gnu.org/licenses/>.
  ==================================================================
*/ 
#include <iostm8s105.h>
#include "stm8_hw_init.h"
#include "scheduler.h"

extern uint32_t t2_millis;    // needed for delay_msec()
extern uint16_t flow[];
extern uint8_t  keypressed[];
extern int8_t   mode[];
extern bool     rotenc_sw;

/*-----------------------------------------------------------------------------
  Purpose  : This is the interrupt routine for the Timer 2 Overflow handler.
             It runs at 1 kHz and drives the scheduler and the multiplexer.
             Measured timing: ?.? usec and ?? usec duration (?.? %).
  Variables: -
  Returns  : -
  ---------------------------------------------------------------------------*/
@interrupt void TIM2_UPD_OVF_IRQHandler(void)
{
    PD_ODR |= ISR_TIME; // Time-measurement interrupt routine
    t2_millis++;        // update millisecond counter
    scheduler_isr();    // Run scheduler interrupt function
    TIM2_SR1 &= ~TIM2_SR1_UIF;  // Reset interrupt (UIF bit) so it will not fire again straight away.
    PD_ODR   &= ~ISR_TIME;      // Time-measurement interrupt routine
} // TIM2_UPD_OVF_IRQHandler()

/*-----------------------------------------------------------------------------
  Purpose  : This is the PORTA interrupt routine.
             It is used to count the falling-edges generated by the four
             water flow sensors. It uses the global variable flow[].
  Variables: -
  Returns  : -
  ---------------------------------------------------------------------------*/
@interrupt void PORTA_IRQHandler(void)
{
    uint8_t porta = ~(PA_IDR & (FLOW1 | FLOW2 | FLOW3 | FLOW4));
    
    if (porta & FLOW1) flow[V1]++; // Count falling edges
    if (porta & FLOW2) flow[V2]++;
    if (porta & FLOW3) flow[V3]++;
    if (porta & FLOW4) flow[V4]++;
} // PORTA_IRQHandler()

/*-----------------------------------------------------------------------------
  Purpose  : This is the PORTC interrupt routine.
             It is used to read the switch of the rotary encoder. 
  Variables: rotenc_sw (global)
  Returns  : -
  ---------------------------------------------------------------------------*/
@interrupt void PORTC_IRQHandler(void)
{
    rotenc_sw = true;
} // PORTC_IRQHandler()

/*-----------------------------------------------------------------------------
  Purpose  : This is the PORTE interrupt routine.
             It is used to read the status of the switch that controls the
             start of the filling process.
  Variables: keypressed[] (global)
  Returns  : -
  ---------------------------------------------------------------------------*/
@interrupt void PORTE_IRQHandler(void)
{
    if (mode[V1] != MODE_OFF) keypressed[V1] = true;
    if (mode[V2] != MODE_OFF) keypressed[V2] = true;
    if (mode[V3] != MODE_OFF) keypressed[V3] = true;
    if (mode[V4] != MODE_OFF) keypressed[V4] = true;
} // PORTE_IRQHandler()

/*-----------------------------------------------------------------------------
  Purpose  : This routine returns the value to Timer 1, which corresponds
             directly to the Rotary Encoder value.
  Variables: -
  Returns  : the Rotary Encoder value
  ---------------------------------------------------------------------------*/
uint16_t get_timer1_value(void)
{
    uint16_t tmpcntr = 0;
    
    tmpcntr = ((uint16_t)TIM1_CNTRH << 8);
    return (uint16_t)(tmpcntr | (uint16_t)(TIM1_CNTRL));
} // get_timer1_value()

/*-----------------------------------------------------------------------------
  Purpose  : This routine initialises the system clock to run at 16 MHz.
             It uses the internal HSI oscillator.
  Variables: -
  Returns  : -
  ---------------------------------------------------------------------------*/
void initialise_system_clock(void)
{
    CLK_ICKCR  = 0;                //  Reset the Internal Clock Register.
    CLK_ICKCR |= CLK_ICKCR_HSIEN;  //  Enable the HSI.
    while ((CLK_ICKCR & CLK_ICKCR_HSIRDY) == 0); //  Wait for the HSI to be ready for use.
    CLK_CKDIVR     = 0;            //  Ensure the clocks are running at full speed.
 
    // The datasheet lists that the max. ADC clock is equal to 6 MHz (4 MHz when on 3.3V).
    // Because fMASTER is now at 16 MHz, we need to set the ADC-prescaler to 4.
    ADC_CR1     &= ~ADC_CR1_SPSEL_MSK;
    ADC_CR1     |= 0x20;          //  Set prescaler (SPSEL bits) to 4, fADC = 4 MHz
    CLK_SWIMCCR  = 0x00;          //  Set SWIM to run at clock / 2.
    CLK_SWR      = 0xE1;          //  Use HSI as the clock source.
    CLK_SWCR     = 0x00;          //  Reset the clock switch control register.
    CLK_SWCR    |= CLK_SWCR_SWEN; //  Enable switching.
    while ((CLK_SWCR & CLK_SWCR_SWBSY) != 0);  //  Pause while the clock switch is busy.
} // initialise_system_clock()

/*-----------------------------------------------------------------------------
  Purpose  : This routine initialises Timer 2 to generate a 1 kHz interrupt.
             16 MHz / (  16 *  1000) = 1000 Hz (1000 = 0x03E8)
             It also initialises Timer 1 to read the status of a Rotary
             Encoder.
  Variables: -
  Returns  : -
  ---------------------------------------------------------------------------*/
void setup_timers(void)
{
    // Set Timer 2 for an Interrupt frequency of 1 kHz
    TIM2_PSCR = 0x04;         //  Prescaler = 16
    TIM2_ARRH = 0x03;         //  High byte of 1000
    TIM2_ARRL = 0xE8;         //  Low  byte of 1000
    TIM2_IER  = TIM2_IER_UIE; //  Enable the update interrupts, disable all others
    TIM2_CR1  = TIM2_CR1_CEN; //  Finally, enable the timer
    
    // Set Timer 1 for a Rotary Encoder
    TIM1_ARRH   = 0x03; // Autoreload value: High byte of 1000
    TIM1_ARRL   = 0xE8; // Autoreload value: Low  byte of 1000
    TIM1_CNTRH  = 0x01; // Load Timer 1 with 500 (halve of autoreload value)
    TIM1_CNTRL  = 0xF4; // Load Timer 1 LSB
    TIM1_PSCRH  = 0x00; // Prescaler high byte
    TIM1_PSCRL  = 0x10; // Prescaler is 16, clock is 1 MHz
    TIM1_CR1    = 0x00; // Edge-aligned mode, up-counter
    TIM1_RCR    = 0x01; // Repetition-rate
    TIM1_CCER1  = 0x22; // Set CC1P and CC2P: falling-edge
    TIM1_SMCR   = 0x03; // Encode mode 3, counts up/down on TI1FP1/TI2FP1 edges
    TIM1_CCMR1  = 0x01; // CC1 is input, IC1 is mapped to TI1FP1
    TIM1_CCMR2  = 0x01; // CC2 is input, IC2 is mapped to TI2FP2
    TIM1_CR1   |= 0x01; // Finally, enable the timer
} // setup_timers()

/*-----------------------------------------------------------------------------
  Purpose  : This routine initialises all the GPIO pins of the STM8 uC.
             See stc1000p.h for a detailed description of all pin-functions.
  Variables: -
  Returns  : -
  ---------------------------------------------------------------------------*/
void setup_gpio_ports(void)
{
    PA_DDR     &= ~(FLOW4 | FLOW3 | FLOW2 | FLOW1);     // Set as inputs
    PA_CR1     |=  (FLOW4 | FLOW3 | FLOW2 | FLOW1);     // Set to push-pull 
    PA_CR2     |=  (FLOW4 | FLOW3 | FLOW2 | FLOW1);     // Enable Interrupt 
	EXTI_CR1   |=  0x02;  // PAIS bits to Falling edge
    
    PB_DDR     |=  (PB_R4 | PB_G4 | PB_B4 | PB_R3 | PB_G3 | PB_B3); // Set as output
	PB_CR1     |=  (PB_R4 | PB_G4 | PB_B4 | PB_R3 | PB_G3 | PB_B3); // Set to push-pull
    PB_ODR     |=  (PB_R4 | PB_G4 | PB_B4 | PB_R3 | PB_G3 | PB_B3); // All RGB LEDs off
    
    PC_DDR     |=  (VALVE4 | VALVE3 | VALVE2 | VALVE1); // Set as outputs
    PC_CR1     |=  (VALVE4 | VALVE3 | VALVE2 | VALVE1);	// Set to Push-Pull
    PC_ODR     &= ~(VALVE4 | VALVE3 | VALVE2 | VALVE1); // All valves are OFF
    PC_DDR     &= ~(ROTENC_A | ROTENC_B | ROTENC_SW);   // set as Input
    PC_CR1     |=   ROTENC_A | ROTENC_B | ROTENC_SW;    // Enable pull-up
    PC_CR2     |=   ROTENC_SW;                          // Enable interrupt
	EXTI_CR1   |=  0x20;  // PAIS bits to Falling edge (0x20 for PORTC)

	PD_DDR     |=  (PD_R1 | PD_G1 | PD_B1 | ISR_TIME);  // Set as output
    PD_CR1     |=  (PD_R1 | PD_G1 | PD_B1 | ISR_TIME);  // Set to Push-Pull
    //PD_DDR     &= ~RX;                                // Set as input
    //PD_CR1     |=  RX;                                // Enable Pull-up
    PD_ODR     |=  (PD_R1 | PD_G1 | PD_B1);             // Init. to 0
    PD_ODR     &= ~ISR_TIME;
    
    PE_ODR     |=  (I2C_SCL | I2C_SDA); // Must be set here, or I2C will not work
    PE_DDR     |=  (I2C_SCL | I2C_SDA);                 // Set as outputs
	PE_DDR     |=  (PE_R2 | PE_G2 | PE_B2);             // Set as output
    PE_CR1     |=  (PE_R2 | PE_G2 | PE_B2);             // Set to Push-Pull
    PE_ODR     |=  (PE_R2 | PE_G2 | PE_B2);             // Set to Push-Pull
    PE_DDR     &= ~PE_SW1;                              // Set as input
    PE_CR1     |=  PE_SW1;                              // Enable Pull-up
    PE_CR2     |=  PE_SW1;                              // Enable interrupt
	EXTI_CR2   |=  0x02;  // PEIS bits to Falling edge
} // setup_gpio_ports()
